import "dotenv/config";
import { createClient } from "@supabase/supabase-js";
import fs from "fs/promises";
import path from "path";
import { camelCase } from "change-case";

const url = process.env.NEXT_PUBLIC_SUPABASE_URL; // https://<project>.supabase.co
const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY; // server-only key
if (!url || !serviceKey) {
  console.error(
    "Missing NEXT_PUBLIC_SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY in .env.local"
  );
  process.exit(1);
}

const supa = createClient(url, serviceKey, { auth: { persistSession: false } });
const bucket = "assets";

// Categories you want in your export
const categories = [
  { exportKey: "about", prefixes: ["images/about-images"] },
  { exportKey: "content", prefixes: ["images/content-images"] },
  { exportKey: "hero", prefixes: ["images/hero-images", "images/heroes"] }, // support either
  { exportKey: "logo", prefixes: ["images/logo-images", "images/logo"] },
  { exportKey: "illustrations", prefixes: ["images/illustrations"] },
];

async function listFirstExistingPrefix(prefixes) {
  for (const p of prefixes) {
    const { data, error } = await supa.storage
      .from(bucket)
      .list(p, { limit: 1000, sortBy: { column: "name", order: "asc" } });
    if (error) continue;
    if (Array.isArray(data)) return { prefix: p, entries: data };
  }
  return { prefix: null, entries: [] };
}

function isFile(entry) {
  // Heuristic: files usually have metadata.size; folders don't.
  // If metadata is missing, treat anything with a dot as a file.
  return entry?.metadata?.size || /\.[a-z0-9]+$/i.test(entry.name);
}

function toKey(filename) {
  const base = filename.replace(/\.[^.]+$/, ""); // remove extension
  return camelCase(base); // “hero-image_01.jpg” → “heroImage01”
}

function toPath(prefix, filename) {
  return `${prefix}/${filename}`.replace(/\/+/g, "/");
}

async function run() {
  const result = {};

  for (const cat of categories) {
    const { prefix, entries } = await listFirstExistingPrefix(cat.prefixes);
    const files = (entries || []).filter(isFile);

    // Build map: { key: "images/<cat>/file.ext" }
    const map = {};
    const used = new Set();
    for (const f of files) {
      let key = toKey(f.name);
      // Ensure unique keys
      let i = 2;
      while (used.has(key)) {
        key = `${toKey(f.name)}${i++}`;
      }
      used.add(key);
      map[key] = toPath(prefix || cat.prefixes[0], f.name);
    }

    result[cat.exportKey] = map;
  }

  // Emit the JS module
  const outFile = path.join(process.cwd(), "content", "images", "images.jsx");
  const header = `// AUTO-GENERATED by scripts/generate-images-js.mjs
// Do not edit by hand; run \`node --env-file=.env.local scripts/generate-images-js.mjs\`
// Paths are relative to the Supabase bucket and work with your /images/* rewrite or SupabaseImage component.

`;
  const body = `const images = ${
    JSON.stringify(result, null, 2)
    // keep nice trailing commas and unquote keys a bit (cosmetic); optional
  };

export const aboutImages = images.about;
export const contentImages = images.content;
export const heroImages = images.hero;
export const logoImages = images.logo;
export const illustrations = images.illustrations;

export default images;
`;

  await fs.mkdir(path.dirname(outFile), { recursive: true });
  await fs.writeFile(outFile, header + body, "utf8");
  console.log(`Wrote ${outFile}`);
}

run().catch((e) => {
  console.error(e);
  process.exit(1);
});
